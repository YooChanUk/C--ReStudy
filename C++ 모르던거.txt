unsigned 는 양수만 취급한다.
signed 는 생략된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
언사인드는 8비트(1바이트) 일경우 0~255가지의 숫자를 표현한다.
사인드는 범위를 지정하여 128~127까지의 숫자를 표현한다.
언사인드에 -1을 집어넣으면 255로 표현되며
사인드에 255를 집어넣으면 비트 표현의 첫번째는 부호를 표현하기에
1111 1111 = -1로 표현된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
정수형과 실수형의 비트 단위는 완전히 다르게 구성됨
실수형(부동소수점 방식)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
실수형식에 f를 안붙이면 자동으로 더블로 인식
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
증감연산자는 가능하면 전위로 써라
++A(O)
--A(O)
A++(X)
A--(X)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
디파인 전처리기 사용에 의의는 가독성의 의의
상태처리시에 내가 모든 상태의 숫자번호를 기억하기엔 무리
Frozen이 20번이라면 20번이 아닌 Frozen 상태를 쳐서 숫자를 넣어버리자
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
배열이 아닌 비트자리로 상태를 넣을수도있음
iStatus |= HUNGRY 첫번째비트 1로 on
iStatus |= THIRSTY 두번쨰비트 2로 on 1.2.4.8.16 이렇게 비트단위로 넣을수도있음

iStatus & THIRSTY 이 비트만 1인지 계산하여 1이면 if문으로 돌리수도있음
if(iStatus & THIRSTY) if(iStatus && THIRSTY)이 두가지는 다름 왼쪽은 그 비트에있는게 1인지 오른쪽은
두가지 모두가 1인지(이 경우는 당연히 1이라고 나온다)

특정자리 비트제거는 iStatus &= ~HUNGRY

상태를 여러개 추가할때 비트 식으로 1,2,4,8,씩 추가하면 너무 커진다.
16진수를 이용하여 편하게 표현하면 비트 연산할때 굉장히편하다
0x001 0x002 0x004 0x008 0x010(16) 0x020(32)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[단축키]
주석 한번에 달기 Ctrl + k,c
주석 한번에 풀기 Ctrl + k,u
원하는 영역 드래그 Alt + Drag

디버깅 관련
디버깅 시작 및 다음 중단점까지 한번에 넘기기 F5
중단점 걸기 및 해제 F9
구문 한줄씩 실행 F10(함수 포함 한번에 실행)
따로 함수진입 F11
디버깅 종료 shift + F5
함수 선언위치, 변수 선언위치로 이동 F12
함수 바로 정의하기 ctrl + .

변수명 바꿀때 관련된 페이지의 변수명 모두 바꾸기 ctrl+r+r
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
include는 말 그대로 복사 붙여넣기이다.
func.h 에 add,sub,mul 이런 함수가 있고 글로벌 변수 선언하여 이곳저곳에 include하면
모든곳에 그 변수가 존재하여 컴파일시 오류가 발생한다.

[정적변수] - 파일(함수)전용 정적변수
이로인해 모든 파일이 합쳐지기 전에 같은 이름의 변수(전역변수)가 존재하면 컴파일 에러가뜨지만
static 정적 변수로 이곳저곳에 선언할시에는 그 파일안에 하나의 존재만 존재하게된다.(메모리영역에 존재하는 cpp파일안에 하나의 이름을 가진 유일무이한 존재) 그렇기에 다른 파일에서 전역변수로 선언된 이름과 동일시 되지않음(메모리 영역이 다르게 되있으며 고정되어있기에(바뀌지 않기에))

static은 무조건 데이터 영역에 들어간다. 그렇기에 스택 함수 영역에 들어가있어도 함수가 호출되거나 종료될때 사라지거나 하지 않고 프로그램이 종료되기까지 자신의 데이터를 유지한다.
지역변수에 있을때는 그 지역변수안에서만 유지되며 전역변수인경우 그 파일안에서만 유지된다.

누군가 전역변수를 쓸수도있지만 내가 스태틱 변수로 함수안에 설정할시 그 안에서만 횟수를 바꾸거나 할수있기에
기능제한으로 인해 조금 더 폐쇄적으로 변수 사용을 유도할수있다.(써야하는곳에만 쓰게끔)

static은 데이터영역에 저장될때 한번만 호출되고 끝난다.(최초 초기화 이후 건너뜀)

[외부변수]
extern 은 외부변수라고한다.
extern은 초깃값을 주면 안된다.(모든곳에 전역변수로 사용하고싶을때)\
어떤 파일이든 어딘가에 한번만 선언되면 된다.(헤더파일이 아닌 다른 cpp파일에)
한번만 선언되면 그 이후 모든곳에서 사용이 가능하다.
+ header파일을 cpp파일에 선언하는곳에 include도 할 필요 없다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
포인터변수에 nullptr은 0이지만 아무것도 지정하지않았다는 의미이다.
int 포인터변수 선언시 int변수의 주소를 저장할수있다.

주소의 단위는 바이트, 주소는 정수타입이다.(비트단위 주소 보유 불가능)

포인터변수는 만들어질떄부터 답이 정해져있다. int 포인터변수는 int만 float는  float만

포인터 변수선언시 자료형의 의미는 그 해석자체를 int나 float식으로 해석하겠다 의미이다. float는 부동소수점 방식이라 해석이 다르다.
포인터는 플랫폼을 따라 바이트가 변경된다 지금 os에따라 바뀌기에 지금은 8바이트
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
const 포인터

cont int* pConstInt 는 원본은 바꿀수없다. 그러나 포인터변수의 주소는 바꿀수있게끔되있다.
int* const pIntConst는 원본을 바굴수 있지만 포인터변수 자체를 바꾸지 못하게된다 
cont int* const pConstInt 한번 초기화만 가능하고 그 뒤 주소와 원본값 둘다 바꾸지못함

ctrl+shift+space 시 함수 선언시의 파라미터 내용을 볼 수 있다
const를 쓴다는건 내가 원본데이터를 읽기만 하겠다는 의미를 전달할 수 있다.

4byte인 int 데이터 가져오는데 8byte 먹는 포인터보다는 복사 붙여넣기가 확실히 오히려 낫지만
구조체이거나 클래스를 주소로 받아오는경우엔 포인터로 가져오는게 낫다(무엇보다 그것이 참조가 많이 되는 상황일수록)

void 포인터의 경우는 아무것도 리턴하지 않는 다는 특징이기때문에 해석자체를 못한다. 그렇기에 포인터변수에 주소를 넣을순있어도
그것을 해석하는 역참조 기능이 없다 * <- 이기능으로 원본값을 알아내기가 어렵다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
문자를 2바이트로 쓰겠다라고 하기위해서는 wchar_t wc = L'a'; 앞에 L자를 붙여줘야한다. 문자 하나하나가 2바이트임을 알려줌
문자열 끝에는 항상 보이지 않는 0 문자가 있다. null
호환성의 문제로 더이상은 char 방식이 아닌 2 바이트 문자형의 wchar 방식이 표준이다.(유니코드)방식
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
문자가 몇개인지 알려주는 함수 wcslen(&)
문자 이어붙이기 wcscat_s(); 첫번째 변수에 두번째 변수를 이어붙인다. 첫번째변수가 바뀌기에 const가 붙어있지 않다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
if문이나 조건구문에 상수를 먼저 적고 변수와 대조하는 습관을 기르면 컴파일부문에서 걸러낼수있어 유용하다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
오버로딩은 같은 이름으로 여러개의 함수를 만들었을때 사용되는 단어이다(오버로딩은 함수 이름은 같지만 파라미터가 다른경우이다.)
오버로딩은 파라미터의 다름으로 호출되는 함수가 다르다. 그렇기에 여러개의 함수를 만들어도 상관없다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
assert로 사용자에게 경고를 내보낼수있다. try catch..?
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
변수는 자료형으로 실체를 만들었을때 생성된다.
구조체 안의 자료형은 멤버다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[동적할당]
include<iostream>
malloc은 힙영역으로 미리 주소공간을 마련해놓는다 입력인자로 바이트수를 요청한다. 주소공간을 마련해놓는것이기 떄문에
포인터형식으로 받아와야한다.
void 포인터 형식으로 되있다. 순수하게 주소값만을 넘겨주는것이기에 어떤 포인터해석을 할지는 사용자의 몫이다.
free는 힙메모리 영역주소를 해제시켜줌 변수가 사라지는게 아님
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[가변배열]
가변배열은 힙메모리영역을 통해서만 생성이 가능하다. int a = 100;인 지역 변수를 배열 인덱스로 사용할수는 없다.
구조체 안쪽에 변수를 가변 배열로 설정하고싶다면 우리는 힙메모리 영역을 쓸것이기에 malloc void형태의 주소값을 전달받을것이다.
그렇기에 그것을 받으려면 구조체에서는 포인터형식의 변수를 가지고 있어야 그 영역을 쓸수있다.
또한 현재까지 들어온 데이터가 몇개들어왔는지 체크하기위한 카운트변수도 있으면 좋다.
또한 동적할당이기에 최대치를 넘어가면 안되기때문에 몇개들어왔는지 체크하면서도 그것이 최대치를 넘지 않는지 최대치까지 기록해놓을수 있는 변수도 있으면 좋다.

free로 해제시에는 카운트변수와 최대변수도 0으로 초기화시켜주면 다음에 쓸때 좋다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[함수포인터]
소트 함수는 하나인데 어떤 소트를할지 인자만 받아와서 쓰는것이 예시다
파라미터에 함수의 주소를 붙여서 주소인자 처럼 보내도 되고 함수는 자체가 주소이기때문에 이름 그대로 써도된다.
void(*pFunc)(void) = Test;
반환타입이 보이드이고 인자도없는 함수의 주소를 받는다.
*pFunc는 함수포인터 변수의 이름이 되며 전 void는 반환타입 후 (void)는 인자타입이다.

함수호출시마다 파라미터를 여러번 정의해서 넣어줘야하는것보다는 미리 세팅해놓은 함수포인터를 이용하면 큰인자값 하나만 넘기면
그 인자값의 나머지를 알아서 세팅한대로 호출해주기에 편한 이점이있다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[C++로 넘어감, 클래스에대하여]
구조체 구문에서 더 이상 한번 더 재정의 해줄 필요가없음
클래스도 자료형을 지정해주는것과 비슷하다. 그러나 접근제한 지정자가 생겼다.

사용법(private: 
             int m_i; 콜론이후부터 지정됨)

생성자를 클래스에서 지원해준다.
본인 클래스 이름과 같은 함수를 지정해주면 되고 반환타입이없다.
그러나 이것은 두단계에 걸친 초기화 타입이기에 제대로된 초기화는 이니셜라이저를 지원하기에
CMy()
     :m_i(100) <- 이것이 생성되자마자 초기화해주는법
{

}


클래스에서는 객체가 끝날때 자동으로 호출되게해주는 문법이 있다.(소멀자)
물결표시(~)와 함께 해당 클래스이름을 해주면된다.
~CMy()
{
}

내가 만든 객체를 연산자를 만들어서도 함수처럼 사용할수 있게 할수있다.
대입연산자의 경우는 미리 컴파일러에서 상정하고 만들었기에 내가 만든 객체와 객체끼리 대입이 되도록
만들어져있다.
c3=c2 이렇게

+의 경우도 함수처럼 만들어서 내가 c3+c2했을때 안에있는 멤버변수끼리 더해지게끔 만들 수 있다.
사용법 void operator[] + () - * (파라미터)

자료형의 *이붙으면 자료형의 포인터타입이 되는것이고
*포인터변수 이렇게하면 역참조를 하겠다는것이고
&변수를 붙이면 본인의 주소값을 반환이지만

자료형옆에 (자료형& 변수명;) 이렇게 되면 무엇이되나?
레퍼런스 변수선언이라고 한다.

int a = 10;
int* p = &a;
*p = 100;

int& iRef = a;
iRef = 100;

위 둘은 똑같은 결과를 실행한다. 위의 경우는 int* const p = &a와 int& iRef = a; 와 같은 결과이다.
const가 변수 앞에 붙으면 포인터변수 자체가 상수화 되는것이기에 한번 선언되면 그 뒤로 바꿀 수 없음을 알린다.
그렇기에 iRef의 경우는 a의 주소값을 받고 그 뒤로 상수화 된다.

반환타입이 레퍼런스인경우 오퍼레이터 연산을 통해 클래스 객체를 배열처럼 만들수도있다.
레퍼런스는 파라미터 데이터를 가져와 그 변수의 주소값 자체가 본인이되는것이기에 직접적으로 내용을 바꿀 수 있게된다.

이경우는 어차피 주소값이 상수화되기때문에 주소값을 건들필요가 없다 그렇기에 사용자가 주소값에 대해 실수 할 여지를 주지 않는다.

C++의 동적할당은 malloc이 아닌 new 라는 새로운 키워드가생긴다.
new int[2];
동적할당해제는 free가 아닌 delete 여러개 묶음이면 delete[]
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[템플릿]
함수 템플릿의 경우는
template<typename T>
T add(T a,T b)
{
  return a+b;
}

변화가 생기는 부분 T부분 자료형을 변경시 오버로딩을 따로 할 필요없이 알아서 변경되어 저 함수 하나로 자료형이 다른 함수를 사용할수있다.
사용법은
add<int>(10,20); 이렇게 사용된다 <자료형>

클래스템플릿은 위에 template<typename T> 만 적어주면된다.


T의 경우는 앞으로 얼마나 큰 데이터를 받아올지 가늠할수없기때문에 지역변수에 복사해와서 사용하는것보다는
참조 그 자체로 원본을 받아오는게 더 좋은방식이다. 그렇기에 원본은 바꿀수없되 어떤것이든 허용할수있게 
const T& 변수명 이렇게 써주는게 더 좋다.

클래스 템플릿의 함수를 정의해준것들은 cpp파일이 아닌 헤더파일에 있어야한다.

함수구현시에도 함수위에 template<typename T> 적어주고 멤버함수가 어디멤버함수 인지는 CArr<T>::CArr() 이렇게 적어줘야한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
네임스페이스는 구분점을 적어주는것이다.
일반적으로 함수안에 
{
} 아무것도없이 대괄호를 적어주는것과 같지만

이경우에는 이름을 정해주어 전역변수처럼 쓸수있다.
Myname 이라는 네임스페이스를 지정해주면
Myname::ghgh 라는 변수를 쓸수있으며 ghgh라는 전역변수가 여러곳에서 사용된다면
마치 count같은 변수
Myname::count
Myalso::count 이렇게 여러개로 만들어서 쓸수있게끔 해준다.

네임스페이스는 이런식으로 변수나 객체를 구분해서 쓸수있게끔 만들어준것이기에 :: 구분점을 찍어줘야하지만
using namespace Myname 이런식으로 앞에 구분을 없앨수도있다. 그러나 이것은 제약을 없애는것이기도하고 나중에 그 안의 변수를 내가 다른 이름으로
지정할수도있기에 쓰지 않는걸 권장한다.

따로 이 변수만 네임스페이스를 쓰지 않고 사용하는 방법은
using Myname::count 이런식으로 쓰면 myname에 있는 count는 myname:: 이것을 쓰지 않아도 쓸수있다. 대신 또 선언하거나 하면 안된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[이터레이터]
iterator 라고하는 STL에서 지원해주는 위치를 찾는 시스템이다.
vector와 list에서는 erase라는 데이터 위치 삭제를 지원해주는데 그것을 이용하기위해서는 iterator로 위치를 가리켜줘야하며
iterator는 이너클래스(클래스 안의 클래스)이다.

클래스 안의 클래스가 있다해서 iterator 클래스가 동시생성되는것이 아니다.
집을 샀더니 의자가 같이 있는 경우가 아닌 iterator 객체를 또 만들어주면 그 클래스만 따로 용량을 가진다.
이너클래스는 그저 이름을 구분 지어준 클래스일뿐 상위 객체를 만든다해서 같이 생성되는것이 아니다.

이터레이터의 begin은 vector가 Resize될때 갱신되지 않기 때문에 그 전 힙메모리에 저장되있는 vector의 배열에 접근하려고 할것이다.
그렇기에 정확한 힙메모리 주소를 알고있는 vector의 객체 원본 데이터를 알고있어야지 Resize되어도 힙메모리에 정확히 접근할 수 있다.

이너클래스는 자신을 포함해준 클래스의 private멤버에 접근이 가능하다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[트리]
그래프는 도표의 그래프가 아닌 간선이 이어져있는 노드로 이루어진 구조를 일컫는다.
트리는 비순회구조이며 그래프의 구조는 이어져있는 순회 구조로 이루어져 있다.
그래서 트리는 계층관계에 더욱 알맞는다.

부모없는 노드(맨위노드) 루트노드
트리의 레벨(높이)는 0부터 또는 1부터 시작할수도있다. 가장밑단까지 센 숫자가 레벨이다.
리프노드(자식없는노드)(맨아래노드) 단말노드

BST(binary search tree)

전위 부모-왼-오
중위 왼-부모-오(정렬은 중위)
후위 왼-오-부모

set과 map 라이브러리가 존재한다. set은 보통적으로 잘 안 씀
map은 typename 2개지정(자료형) 첫번째가 키값 두번째가 밸류값

map의 변수형에 insert를 해주고 싶으면 make_pair 라이브러리를 사용해야한다.
make_pair(L"홍길동",info) 이와 같은 내용이 파라미터로 들어간다.
make_pair는 키값과 데이터내용을 하나로 묶어서 전달해주는 라이브러리이다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[wstring]
wstring은 일반 상수형 문자열 "안녕!" 처럼 const wchar_t의 형식을 취하지 않는다.
wstring은 일반 변수처럼 주소값을 따로 가지고 그 안에 데이터를 저장하는 형식을 취한다. 나머지 함수가 operating 오버로딩된 형식으로 == 비교가 가능하다.
또한 무한정으로 데이터를 더하거나 할 수 있기 떄문에 동적관리형식이다(힙메모리) 문자열이기에 vector형식을 취하고 있는것과도 같다.
vector<char> 이런 형식과 비슷하다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[enum]
열거형

안쪽에 이름을 하나씩 넣어놓는다. 컴파일러는 이 정해진 이름을 연속된 숫자로 인식하여 받아들인다. 0,1,2,3,4
내가 임의로 숫자를 지정도 가능하다.
똑같은 이름으로 이름을 정해줄 수도 있어서 중복되어 재정의 됐다고 오류가 뜨는 일이 빈번하여
enum class라는게 추가가되었다.

enum class
클래스와 같이 클래스 이름을 앞에쓴 뒤 :: 이것을 붙여줘야한다. ex) MY_TYPE::TYPE_1; 또한
별개의 타입 및 이넘 자료형으로 보기 때문에 정수형으로 바꾸고싶으면 명시적으로 캐스팅을 해줘야한다.
ex) (int)MY_TYPE::TYPE_1;

#define과의 차이는 전처리기 이기에 컴파일이 되기 이전에 실행된다.
그렇기 때문에 실행시 define코드가 적혀있는게 아닌 define의 데이터만 덩그러니 들어간다.

그렇기에 직관적으로 확인이 가능하여 디버깅이 가능한 enum이 조금 더 효율이 좋다.